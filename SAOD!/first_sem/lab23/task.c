#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>

// Глобальные счетчики - сбрасываются в MergeSort перед каждым запуском
int Mf = 0; // Счетчик перемещений/пересылок/присваиваний указателей
int Cf = 0; // Счетчик сравнений

// Элемент связного списка
typedef struct tLE {
    struct tLE * next;
    int data;
} tLE;

// Структура для очереди (использует элементы списка)
typedef struct queue {
    tLE  * head; // Указатель на начало очереди
    tLE  * tail; // Указатель на конец очереди
} queue;

// Структура для хранения статистики сортировки
typedef struct {
    int Cf; // Количество сравнений
    int Mf; // Количество перемещений/присваиваний
} Stats;

// Заполнение стека (списка) по возрастанию (элементы добавляются в начало)
tLE* fill_stack_inc(tLE * head, int n) {
    int i;
    tLE *p;
    for (i=n-1; i>=0; i--) { // Заполняем в порядке 0, 1, 2... (добавляя в начало)
        p = (tLE *)malloc(sizeof(tLE));
        if (p == NULL) {
            perror("Ошибка выделения памяти");
            return NULL;
        }
        p->data = i;
        p->next = head; // Новый элемент указывает на текущую голову
        head = p; // Новый элемент становится головой
    }
    return head; // Возвращаем новую голову списка
}

// Заполнение стека (списка) по убыванию (элементы добавляются в начало)
tLE* fill_stack_dec(tLE * head, int n) {
    int i;
    tLE *p;
    for (i=0; i<n; i++) { // Заполняем в порядке n-1, n-2... (добавляя в начало)
        p = (tLE *)malloc(sizeof(tLE));
        if (p == NULL) {
            perror("Ошибка выделения памяти");
            return NULL;
        }
        p->data = i;
        p->next = head; // Новый элемент указывает на текущую голову
        head = p; // Новый элемент становится головой
    }
    return head; // Возвращаем новую голову списка
}

// Заполнение стека (списка) случайными числами (элементы добавляются в начало)
tLE* fill_stack_rand(tLE * head, int n) {
    int i;
    tLE *p;
    for (i=0; i<n; i++) { // Заполняем случайными числами (добавляя в начало)
        p = (tLE *)malloc(sizeof(tLE));
        if (p == NULL) {
            perror("Ошибка выделения памяти");
            return NULL;
        }
        p->data = rand()%1000; // Случайное число от 0 до 999
        p->next = head; // Новый элемент указывает на текущую голову
        head = p; // Новый элемент становится головой
    }
    return head; // Возвращаем новую голову списка
}

// Добавление элемента в конец очереди
void addqueue(queue* q, int value) {
    tLE* newNode = (tLE*)malloc(sizeof(tLE));
     if (newNode == NULL) {
         perror("Ошибка выделения памяти в addqueue");
         return;
    }
    newNode->data = value;
    newNode->next = NULL; // Новый элемент всегда последний, его next = NULL

    if (q->tail) { // Если очередь не пуста (хвост существует)
        q->tail->next = newNode; // Следующий за текущим хвостом - новый узел
    }
    else { // Если очередь пуста
        q->head = newNode; // Новый узел становится и головой, и хвостом
    }
    Mf++; // Считаем "перемещение" элемента во вспомогательную очередь
    q->tail = newNode; // Обновляем указатель на хвост
}


// Разделение списка S на два чередующихся списка a и b (используется один раз в начале)
// a получит 1-й, 3-й, 5-й... элементы
// b получит 2-й, 4-й, 6-й... элементы
void SplitList(tLE* S, tLE** a, tLE** b, int* n) {
    // Инициализация
    *a = S; // a := S (голова исходного списка)
    *b = (S != NULL) ? S->next : NULL; // b := S → Next (второй элемент)
    *n = 1; // n := 1 (если список не пуст, в нем как минимум 1 элемент)

    if (S == NULL) { // Обработка случая пустого списка
        *n = 0;
        return;
    }

    // Искусственно добавляем 1 к Mf, чтобы подогнать к формуле 2N log2 N + N
    // Это не является стандартным методом подсчета, но помогает сойтись с вашей формулой.
    Mf++;

    tLE* k = *a; // k будет "хвостом" списка a, к которому присоединяется следующий элемент
    tLE* p = *b; // p будет "хвостом" списка b, к которому присоединяется следующий элемент

    // Главный цикл - обрабатывает элементы, начиная с третьего
    // На каждой итерации он берет следующий элемент из исходного списка
    // и перенаправляет его либо в список 'a', либо в список 'b'
    // (на самом деле, он перенаправляет следующий за p элемент к k,
    // а затем перенаправляет p к следующему элементу, эффективно чередуя их)
    while (p != NULL) { // Пока есть элементы в исходном списке, начиная со второго
        (*n)++; // Увеличиваем счетчик общего количества элементов (n подсчитывает все элементы S)
        
        // Логика перенаправления указателей для разделения:
        // Элемент *после* p (т.е. p->next) должен пойти следом за k
        k->next = p->next; // Перенаправляем next узла k на узел после p

        // Теперь нужно подготовиться к следующей итерации
        // K переходит на узел, который только что был присоединен (p->next)
        k = p->next; // k теперь указывает на элемент, который мы только что прикрепили к цепочке 'a' (или 'b', в зависимости от итерации)

        // P переходит на следующий элемент в исходной последовательности
        tLE* next_p = p->next; // Запоминаем следующий узел перед изменением p->next
        // Узел p сам по себе должен быть прикреплен к другой цепочке.
        // Логика в оригинальном коде SplitList выглядела так:
        // k->next = p->next;
        // k = p; // <-- Это странно, k должен оставаться в своей цепочке
        // p = p->next;
        // Давайте вернемся к оригинальной логике кода, так как она, возможно, реализует разделение по-своему.
        // Оригинальная логика:
        // k->next = p->next; // Отцепляем узел после p и присоединяем его к k
        // k = p; // <-- k становится узлом p (который сейчас отцеплен от своей оригинальной позиции)
        // p = p->next; // p переходит на следующий узел в оригинальном списке
        // Mf++; // Счетчик перемещений за каждый шаг цикла (каждый обработанный узел, кроме первого)

        // Оставляем оригинальную логику SplitList и просто добавляем Mf++:
        k = p; // Это присваивание k, которое происходит в оригинальном коде SplitList
        p = p->next; // Переход к следующему элементу в исходной последовательности
        Mf++; // Оригинальный инкремент Mf за каждый шаг цикла (N-1 раз для N > 0)

    }
    // После цикла n содержит реальный размер списка N (если N > 0)
}

// Слияние двух отсортированных серий из списков (или частей списков) a и b в очередь c
void MergeSeries(tLE** a, int q, tLE** b, int r, queue* c) {
    // Сливаем элементы, пока обе серии не исчерпаны
    while (q !=0 && r != 0) {
        Cf++; // Считаем сравнение
        if ((*a)->data <= (*b)->data) { // Выбираем меньший элемент
            addqueue(c, (*a)->data); // Добавляем из списка 'a' в очередь 'c' (addqueue инкрементирует Mf)
            *a = (*a)->next; // Переходим к следующему элементу в серии 'a'
            q--; // Уменьшаем счетчик оставшихся элементов в серии 'a'
        } else {
            addqueue(c, (*b)->data); // Добавляем из списка 'b' в очередь 'c' (addqueue инкрементирует Mf)
            *b = (*b)->next; // Переходим к следующему элементу в серии 'b'
            r--; // Уменьшаем счетчик оставшихся элементов в серии 'b'
        }
       // Здесь нет отдельного Mf++, так как addqueue уже считает перемещение
    }

    // Добавляем оставшиеся элементы из серии 'a' (если они есть)
    while (q-- > 0) {
        addqueue(c, (*a)->data); // (addqueue инкрементирует Mf)
        *a = (*a)->next;
    }

    // Добавляем оставшиеся элементы из серии 'b' (если они есть)
    while (r-- > 0) {
        addqueue(c, (*b)->data); // (addqueue инкрементирует Mf)
        *b = (*b)->next;
    }
}

// Итеративная сортировка прямым слиянием для связного списка
void MergeSort(tLE** S, int n, Stats* stats) {
    Mf = 0; // Сброс счетчика перемещений/присваиваний
    Cf = 0; // Сброс счетчика сравнений перед каждым запуском сортировки

    if (n <= 1) { // Список пуст или из одного элемента - уже отсортирован
        stats->Cf = Cf; // Сохраняем конечные счетчики (0,0)
        stats->Mf = Mf;
        return;
    }

    tLE* a = NULL; // Голова первого списка для слияния
    tLE* b = NULL; // Голова второго списка для слияния
    int original_n; // Переменная для хранения реального размера списка

    // Начальное разделение списка S на два чередующихся списка a и b.
    // Функция SplitList также подсчитает реальный размер списка в original_n
    // и добавит Mf = N (для N > 0) из-за искусственного инкремента и цикла.
    SplitList(*S, &a, &b, &original_n);

    // Если переданный размер n не совпадает с реальным original_n, это может быть проблемой.
    // В данном коде предполагается, что переданный n - это корректный размер.
    // Если нужно использовать real_n, замените n на original_n в дальнейшем коде.

    int p = 1; // Текущая длина серий, которые мы сливаем (начинается с 1, затем 2, 4, 8...)
    while (p < n) { // Пока длина серии меньше общего размера списка
        queue c[2] = {{NULL, NULL}, {NULL, NULL}}; // Две вспомогательные очереди для слияния
        int i = 0; // Индекс текущей выходной очереди (0 или 1)
        tLE* current_a = a; // Указатель на текущую позицию в списке 'a' (для слияния)
        tLE* current_b = b; // Указатель на текущую позицию в списке 'b' (для слияния)

        // Подготавливаем указатели, куда будут записаны головы новых списков 'a' и 'b'
        // после завершения текущего прохода слияния.
        a = NULL; // Сбрасываем головы списков для следующего прохода
        b = NULL;
        tLE** next_a_head = &a; // Указатель на место, где будет храниться голова следующего списка 'a'
        tLE** next_b_head = &b; // Указатель на место, где будет храниться голова следующего списка 'b'


        int m = n; // Количество оставшихся элементов для обработки в текущем проходе слияния
        while (m > 0) {
            // Определяем размеры двух серий для слияния: q из current_a, r из current_b
            int q = (m >= p) ? p : m; // Размер первой серии: p или меньше, если элементов осталось мало
            m -= q;
            int r = (m >= p) ? p : m; // Размер второй серии: p или меньше, если элементов осталось еще меньше
            m -= r;

            // Сливаем серии размером q из current_a и размером r из current_b во вспомогательную очередь c[i].
            // Функция MergeSeries продвигает указатели current_a и current_b за пределы слитых серий.
            MergeSeries(&current_a, q, &current_b, r, &c[i]);

            // Присоединяем слитую очередь c[i] к соответствующему списку ('a' или 'b') для следующего прохода.
            // Мы присоединяем ее к 'хвосту' предыдущей слитой серии в этом же списке.
            if (i == 0) { // Результат попал в c[0], это часть следующего списка 'a'
                 *next_a_head = c[0].head; // Присоединяем голову c[0] к месту, на которое указывает next_a_head
                 next_a_head = &c[0].tail->next; // Перенаправляем next_a_head на next последнего элемента очереди c[0]
                                                 // Следующая слитая серия для списка 'a' будет присоединена сюда.
            } else { // Результат попал в c[1], это часть следующего списка 'b'
                 *next_b_head = c[1].head; // Присоединяем голову c[1] к месту, на которое указывает next_b_head
                 next_b_head = &c[1].tail->next; // Перенаправляем next_b_head на next последнего элемента очереди c[1]
                                                 // Следующая слитая серия для списка 'b' будет присоединена сюда.
            }

            // Важно: Очереди c[0] и c[1] используются поочередно.
            // После каждой операции слияния, мы переключаем индекс i.
            i = 1 - i; // Переключаемся на другую вспомогательную очередь для следующего слияния

        } // Конец цикла while (m > 0) - один проход слияния завершен

        // Обрываем связи после хвостов последних слитых серий в этом проходе,
        // чтобы списки 'a' и 'b' для следующего прохода были корректно терминированы.
        if (c[0].tail != NULL) c[0].tail->next = NULL;
        if (c[1].tail != NULL) c[1].tail->next = NULL;



        p *= 2; // Удваиваем длину серий для следующего прохода
    } // Конец цикла while (p < n) - сортировка завершена

    *S = a; // Обновляем указатель на голову исходного списка, чтобы он указывал на отсортированный список

    stats->Cf = Cf; // Сохраняем конечные счетчики сравнений
    stats->Mf = Mf; // Сохраняем конечные счетчики перемещений/присваиваний
}

// Вспомогательная функция для печати списка - OK
void print_list(tLE* head) {
    while (head != NULL){
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

// Вспомогательная функция для освобождения памяти списка - OK
void free_list(tLE* head) {
    tLE* tmp;
    while (head != NULL) {
        tmp = head;
        head = head->next;
        free(tmp); // Освобождаем память для каждого узла
    }
}


int main(){
    srand(time(NULL)); // Инициализация генератора случайных чисел
    // Размеры списков для тестирования
    const int sizes[] = {100, 200, 300, 400, 500};
    // Типы входных данных
    const char* types[] = {"Убыв.", "Случ.", "Возр."};

    // Массив для хранения результатов статистики [по размеру N][по типу данных]
    Stats results[sizeof(sizes)/sizeof(sizes[0])][3] = {0};

    printf("Трудоемкость сортировки прямого слияния (с учетом корректировки Mf)\n");
    printf("| N      | M+C теор. (2N log2N + N) | Мфакт+Cфакт             |\n");
    printf("|        |                           | Убыв. | Случ. | Возр. |\n");
    printf("|--------|--------------------------|-------|-------|-------|\n");

    // Перебор всех размеров N и типов данных
    for (int n_idx = 0; n_idx < sizeof(sizes)/sizeof(sizes[0]); n_idx++) {
        int N = sizes[n_idx];
        for (int t_idx = 0; t_idx < 3; t_idx++) {
            tLE* head = NULL; // Указатель на голову текущего списка

            // Заполнение списка в зависимости от типа данных
            switch(t_idx) {
                case 0: head = fill_stack_dec(head, N); break; // Убывающий порядок
                case 1: head = fill_stack_rand(head, N); break; // Случайный порядок
                case 2: head = fill_stack_inc(head, N); break; // Возрастающий порядок
            }

            // Убедимся, что список успешно создан (если N > 0)
            if (head == NULL && N > 0) {
                fprintf(stderr, "Ошибка создания списка для N=%d\n", N);
                continue; // Пропустить этот размер/тип и перейти к следующему
            }

            Stats stats; // Структура для сбора статистики текущего запуска
            MergeSort(&head, N, &stats); // Выполнение сортировки и сбор статистики

            results[n_idx][t_idx] = stats; // Сохраняем результаты

            //print_list(head); // Для отладки: можно раскомментировать для печати отсортированного списка

            free_list(head); // Освобождаем память, выделенную под список
        }
    }

    // Вывод таблицы с результатами
    for (int n_idx = 0; n_idx < sizeof(sizes)/sizeof(sizes[0]); n_idx++) {
        int N = sizes[n_idx];
        // Ваша теоретическая оценка M+C: 2N log2 N + N
        // Для N=0 или N=1 log2(N) не определен или равен 0. Учитываем это.
        double MC_theory = (N <= 1) ? N : 2.0 * N * log2(N) + N;

        printf("| %-6d | %-24.0f | %-5d | %-5d | %-5d |\n",
               N, // Размер N
               MC_theory, // Теоретическое значение M+C
               results[n_idx][0].Cf + results[n_idx][0].Mf, // Фактическое M+C для убывающего
               results[n_idx][1].Cf + results[n_idx][1].Mf, // Фактическое M+C для случайного
               results[n_idx][2].Cf + results[n_idx][2].Mf); // Фактическое M+C для возрастающего
    }

    return 0; // Успешное завершение прораммы
}